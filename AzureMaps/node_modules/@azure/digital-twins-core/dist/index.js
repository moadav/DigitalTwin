'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');
var logger$1 = require('@azure/logger');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var DigitalTwinsModelData = {
    type: {
        name: "Composite",
        className: "DigitalTwinsModelData",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            uploadTime: {
                serializedName: "uploadTime",
                type: {
                    name: "DateTime"
                }
            },
            decommissioned: {
                serializedName: "decommissioned",
                type: {
                    name: "Boolean"
                }
            },
            model: {
                serializedName: "model",
                type: {
                    name: "any"
                }
            }
        }
    }
};
var ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "ErrorModel" } }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
var InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
var PagedDigitalTwinsModelDataCollection = {
    type: {
        name: "Composite",
        className: "PagedDigitalTwinsModelDataCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DigitalTwinsModelData" }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var QuerySpecification = {
    type: {
        name: "Composite",
        className: "QuerySpecification",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            continuationToken: {
                serializedName: "continuationToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var QueryResult = {
    type: {
        name: "Composite",
        className: "QueryResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: { type: { name: "any" } }
                }
            },
            continuationToken: {
                serializedName: "continuationToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var RelationshipCollection = {
    type: {
        name: "Composite",
        className: "RelationshipCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: { type: { name: "any" } }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var IncomingRelationshipCollection = {
    type: {
        name: "Composite",
        className: "IncomingRelationshipCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "IncomingRelationship" }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var IncomingRelationship = {
    type: {
        name: "Composite",
        className: "IncomingRelationship",
        modelProperties: {
            relationshipId: {
                serializedName: "$relationshipId",
                type: {
                    name: "String"
                }
            },
            sourceId: {
                serializedName: "$sourceId",
                type: {
                    name: "String"
                }
            },
            relationshipName: {
                serializedName: "$relationshipName",
                type: {
                    name: "String"
                }
            },
            relationshipLink: {
                serializedName: "$relationshipLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var EventRouteCollection = {
    type: {
        name: "Composite",
        className: "EventRouteCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "EventRoute" } }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var EventRoute = {
    type: {
        name: "Composite",
        className: "EventRoute",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endpointName: {
                serializedName: "endpointName",
                required: true,
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
var QueryQueryTwinsHeaders = {
    type: {
        name: "Composite",
        className: "QueryQueryTwinsHeaders",
        modelProperties: {
            queryCharge: {
                serializedName: "query-charge",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var DigitalTwinsGetByIdHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsGetByIdHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsAddHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsAddHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsUpdateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsGetRelationshipByIdHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsGetRelationshipByIdHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsAddRelationshipHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsAddRelationshipHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsUpdateRelationshipHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsUpdateRelationshipHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsGetComponentHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsGetComponentHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DigitalTwinsUpdateComponentHeaders = {
    type: {
        name: "Composite",
        className: "DigitalTwinsUpdateComponentHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DigitalTwinsModelData: DigitalTwinsModelData,
    ErrorResponse: ErrorResponse,
    ErrorModel: ErrorModel,
    InnerError: InnerError,
    PagedDigitalTwinsModelDataCollection: PagedDigitalTwinsModelDataCollection,
    QuerySpecification: QuerySpecification,
    QueryResult: QueryResult,
    RelationshipCollection: RelationshipCollection,
    IncomingRelationshipCollection: IncomingRelationshipCollection,
    IncomingRelationship: IncomingRelationship,
    EventRouteCollection: EventRouteCollection,
    EventRoute: EventRoute,
    QueryQueryTwinsHeaders: QueryQueryTwinsHeaders,
    DigitalTwinsGetByIdHeaders: DigitalTwinsGetByIdHeaders,
    DigitalTwinsAddHeaders: DigitalTwinsAddHeaders,
    DigitalTwinsUpdateHeaders: DigitalTwinsUpdateHeaders,
    DigitalTwinsGetRelationshipByIdHeaders: DigitalTwinsGetRelationshipByIdHeaders,
    DigitalTwinsAddRelationshipHeaders: DigitalTwinsAddRelationshipHeaders,
    DigitalTwinsUpdateRelationshipHeaders: DigitalTwinsUpdateRelationshipHeaders,
    DigitalTwinsGetComponentHeaders: DigitalTwinsGetComponentHeaders,
    DigitalTwinsUpdateComponentHeaders: DigitalTwinsUpdateComponentHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
var models = {
    parameterPath: ["options", "models"],
    mapper: {
        constraints: {
            MinItems: 1,
            UniqueItems: true
        },
        serializedName: "models",
        type: {
            name: "Sequence",
            element: { type: { name: "any" } }
        }
    }
};
var $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
var traceparent = {
    parameterPath: ["options", "traceparent"],
    mapper: {
        serializedName: "traceparent",
        type: {
            name: "String"
        }
    }
};
var tracestate = {
    parameterPath: ["options", "tracestate"],
    mapper: {
        serializedName: "tracestate",
        type: {
            name: "String"
        }
    }
};
var apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-10-31",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
var dependenciesFor = {
    parameterPath: ["options", "dependenciesFor"],
    mapper: {
        serializedName: "dependenciesFor",
        type: {
            name: "Sequence",
            element: { type: { name: "String" } }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
var includeModelDefinition = {
    parameterPath: ["options", "includeModelDefinition"],
    mapper: {
        serializedName: "includeModelDefinition",
        type: {
            name: "Boolean"
        }
    }
};
var maxItemsPerPage = {
    parameterPath: ["options", "maxItemsPerPage"],
    mapper: {
        serializedName: "max-items-per-page",
        type: {
            name: "Number"
        }
    }
};
var id = {
    parameterPath: "id",
    mapper: {
        serializedName: "id",
        required: true,
        type: {
            name: "String"
        }
    }
};
var contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json-patch+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
var updateModel = {
    parameterPath: "updateModel",
    mapper: {
        serializedName: "updateModel",
        required: true,
        type: {
            name: "Sequence",
            element: { type: { name: "any" } }
        }
    }
};
var nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
var querySpecification = {
    parameterPath: "querySpecification",
    mapper: QuerySpecification
};
var twin = {
    parameterPath: "twin",
    mapper: {
        serializedName: "twin",
        required: true,
        type: {
            name: "any"
        }
    }
};
var ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
var ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
var patchDocument = {
    parameterPath: "patchDocument",
    mapper: {
        serializedName: "patchDocument",
        required: true,
        type: {
            name: "Sequence",
            element: { type: { name: "any" } }
        }
    }
};
var relationshipId = {
    parameterPath: "relationshipId",
    mapper: {
        serializedName: "relationshipId",
        required: true,
        type: {
            name: "String"
        }
    }
};
var relationship = {
    parameterPath: "relationship",
    mapper: {
        serializedName: "relationship",
        required: true,
        type: {
            name: "any"
        }
    }
};
var relationshipName = {
    parameterPath: ["options", "relationshipName"],
    mapper: {
        serializedName: "relationshipName",
        type: {
            name: "String"
        }
    }
};
var telemetry = {
    parameterPath: "telemetry",
    mapper: {
        serializedName: "telemetry",
        required: true,
        type: {
            name: "any"
        }
    }
};
var messageId = {
    parameterPath: "messageId",
    mapper: {
        serializedName: "Message-Id",
        required: true,
        type: {
            name: "String"
        }
    }
};
var telemetrySourceTime = {
    parameterPath: ["options", "telemetrySourceTime"],
    mapper: {
        serializedName: "Telemetry-Source-Time",
        type: {
            name: "String"
        }
    }
};
var componentPath = {
    parameterPath: "componentPath",
    mapper: {
        serializedName: "componentPath",
        required: true,
        type: {
            name: "String"
        }
    }
};
var eventRoute = {
    parameterPath: ["options", "eventRoute"],
    mapper: EventRoute
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/**
 * Class representing a DigitalTwinModels.
 */
var DigitalTwinModels = /** @class */ (function () {
    /**
     * Initialize a new instance of the class DigitalTwinModels class.
     * @param client Reference to the service client
     */
    function DigitalTwinModels(client) {
        this.client = client;
    }
    /**
     * Uploads one or more models. When any error occurs, no models are uploaded.
     * Status codes:
     * * 201 Created
     * * 400 Bad Request
     *   * DTDLParserError - The models provided are not valid DTDL.
     *   * InvalidArgument - The model id is invalid.
     *   * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been reached.
     *   * ModelVersionNotSupported - The version of DTDL used is not supported.
     * * 409 Conflict
     *   * ModelAlreadyExists - The model provided already exists.
     * @param options The options parameters.
     */
    DigitalTwinModels.prototype.add = function (options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ options: operationOptions }, addOperationSpec);
    };
    /**
     * Retrieves model metadata and, optionally, model definitions.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The model id is invalid.
     *   * LimitExceeded - The maximum number of model ids allowed in 'dependenciesFor' has been reached.
     * * 404 Not Found
     *   * ModelNotFound - The model was not found.
     * @param options The options parameters.
     */
    DigitalTwinModels.prototype.list = function (options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ options: operationOptions }, listOperationSpec);
    };
    /**
     * Retrieves model metadata and optionally the model definition.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The model id is invalid.
     *   * MissingArgument - The model id was not provided.
     * * 404 Not Found
     *   * ModelNotFound - The model was not found.
     * @param id The id for the model. The id is globally unique and case sensitive.
     * @param options The options parameters.
     */
    DigitalTwinModels.prototype.getById = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, getByIdOperationSpec);
    };
    /**
     * Updates the metadata for a model.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The model id is invalid.
     *   * JsonPatchInvalid - The JSON Patch provided is invalid.
     *   * MissingArgument - The model id was not provided.
     * * 404 Not Found
     *   * ModelNotFound - The model was not found.
     * * 409 Conflict
     *   * ModelReferencesNotDecommissioned - The model refers to models that are not decommissioned.
     * @param id The id for the model. The id is globally unique and case sensitive.
     * @param updateModel An update specification described by JSON Patch. Only the decommissioned property
     *                    can be replaced.
     * @param options The options parameters.
     */
    DigitalTwinModels.prototype.update = function (id, updateModel, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, updateModel: updateModel, options: operationOptions }, updateOperationSpec);
    };
    /**
     * Deletes a model. A model can only be deleted if no other models reference it.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The model id is invalid.
     *   * MissingArgument - The model id was not provided.
     * * 404 Not Found
     *   * ModelNotFound - The model was not found.
     * * 409 Conflict
     *   * ModelReferencesNotDeleted - The model refers to models that are not deleted.
     * @param id The id for the model. The id is globally unique and case sensitive.
     * @param options The options parameters.
     */
    DigitalTwinModels.prototype.delete = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, deleteOperationSpec);
    };
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    DigitalTwinModels.prototype.listNext = function (nextLink, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ nextLink: nextLink, options: operationOptions }, listNextOperationSpec);
    };
    return DigitalTwinModels;
}());
// Operation Specifications
var serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
var addOperationSpec = {
    path: "/models",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DigitalTwinsModelData" }
                    }
                }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: models,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [
        contentType,
        traceparent,
        tracestate
    ],
    mediaType: "json",
    serializer: serializer
};
var listOperationSpec = {
    path: "/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedDigitalTwinsModelDataCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        dependenciesFor,
        includeModelDefinition
    ],
    urlParameters: [$host],
    headerParameters: [
        traceparent,
        tracestate,
        maxItemsPerPage
    ],
    serializer: serializer
};
var getByIdOperationSpec = {
    path: "/models/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DigitalTwinsModelData
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, includeModelDefinition],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer
};
var updateOperationSpec = {
    path: "/models/{id}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: updateModel,
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [
        traceparent,
        tracestate,
        contentType1
    ],
    mediaType: "json",
    serializer: serializer
};
var deleteOperationSpec = {
    path: "/models/{id}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer
};
var listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedDigitalTwinsModelDataCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        dependenciesFor,
        includeModelDefinition
    ],
    urlParameters: [$host, nextLink],
    headerParameters: [
        traceparent,
        tracestate,
        maxItemsPerPage
    ],
    serializer: serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/**
 * Class representing a Query.
 */
var Query = /** @class */ (function () {
    /**
     * Initialize a new instance of the class Query class.
     * @param client Reference to the service client
     */
    function Query(client) {
        this.client = client;
    }
    /**
     * Executes a query that allows traversing relationships and filtering by property values.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * BadRequest - The continuation token is invalid.
     *   * SqlQueryError - The query contains some errors.
     * * 429 Too Many Requests
     *   * QuotaReachedError - The maximum query rate limit has been reached.
     * @param querySpecification The query specification to execute.
     * @param options The options parameters.
     */
    Query.prototype.queryTwins = function (querySpecification, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ querySpecification: querySpecification, options: operationOptions }, queryTwinsOperationSpec);
    };
    return Query;
}());
// Operation Specifications
var serializer$1 = new coreHttp.Serializer(Mappers, /* isXml */ false);
var queryTwinsOperationSpec = {
    path: "/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResult,
            headersMapper: QueryQueryTwinsHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: querySpecification,
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [
        contentType,
        traceparent,
        tracestate,
        maxItemsPerPage
    ],
    mediaType: "json",
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/**
 * Class representing a DigitalTwins.
 */
var DigitalTwins = /** @class */ (function () {
    /**
     * Initialize a new instance of the class DigitalTwins class.
     * @param client Reference to the service client
     */
    function DigitalTwins(client) {
        this.client = client;
    }
    /**
     * Retrieves a digital twin.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.getById = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, getByIdOperationSpec$1);
    };
    /**
     * Adds or replaces a digital twin.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or payload is invalid.
     *   * ModelDecommissioned - The model for the digital twin is decommissioned.
     *   * TwinLimitReached - The maximum number of digital twins allowed has been reached.
     *   * ValidationFailed - The digital twin payload is not valid.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param twin The digital twin instance being added. If provided, the $dtId property is ignored.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.add = function (id, twin, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, twin: twin, options: operationOptions }, addOperationSpec$1);
    };
    /**
     * Deletes a digital twin. All relationships referencing the digital twin must already be deleted.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id is invalid.
     *   * RelationshipsNotDeleted - The digital twin contains relationships.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.delete = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, deleteOperationSpec$1);
    };
    /**
     * Updates a digital twin.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or payload is invalid.
     *   * JsonPatchInvalid - The JSON Patch provided is invalid.
     *   * ValidationFailed - Applying the patch results in an invalid digital twin.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and
     *                      $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.update = function (id, patchDocument, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, patchDocument: patchDocument, options: operationOptions }, updateOperationSpec$1);
    };
    /**
     * Retrieves a relationship between two digital twins.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or relationship id is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     *   * RelationshipNotFound - The relationship was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case
     *                       sensitive.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.getRelationshipById = function (id, relationshipId, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, relationshipId: relationshipId, options: operationOptions }, getRelationshipByIdOperationSpec);
    };
    /**
     * Adds a relationship between two digital twins.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id, relationship id, or payload is invalid.
     *   * InvalidRelationship - The relationship is invalid.
     *   * OperationNotAllowed - The relationship cannot connect to the same digital twin.
     *   * ValidationFailed - The relationship content is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     *   * TargetTwinNotFound - The digital twin target of the relationship was not found.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case
     *                       sensitive.
     * @param relationship The data for the relationship.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.addRelationship = function (id, relationshipId, relationship, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, relationshipId: relationshipId, relationship: relationship, options: operationOptions }, addRelationshipOperationSpec);
    };
    /**
     * Deletes a relationship between two digital twins.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or relationship id is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     *   * RelationshipNotFound - The relationship was not found.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case
     *                       sensitive.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.deleteRelationship = function (id, relationshipId, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, relationshipId: relationshipId, options: operationOptions }, deleteRelationshipOperationSpec);
    };
    /**
     * Updates the properties on a relationship between two digital twins.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or relationship id is invalid.
     *   * InvalidRelationship - The relationship is invalid.
     *   * JsonPatchInvalid - The JSON Patch provided is invalid.
     *   * ValidationFailed - The relationship content is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     *   * RelationshipNotFound - The relationship was not found.
     * * 409 Conflict
     *   * RelationshipAlreadyExists - The relationship already exists.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param relationshipId The id of the relationship. The id is unique within the digital twin and case
     *                       sensitive.
     * @param patchDocument JSON Patch description of the update to the relationship properties.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.updateRelationship = function (id, relationshipId, patchDocument, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, relationshipId: relationshipId, patchDocument: patchDocument, options: operationOptions }, updateRelationshipOperationSpec);
    };
    /**
     * Retrieves the relationships from a digital twin.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.listRelationships = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, listRelationshipsOperationSpec);
    };
    /**
     * Retrieves all incoming relationship for a digital twin.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.listIncomingRelationships = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, listIncomingRelationshipsOperationSpec);
    };
    /**
     * Sends telemetry on behalf of a digital twin.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or message id is invalid.
     *   * ValidationFailed - The telemetry content is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param messageId A unique message identifier (in the scope of the digital twin id) that is commonly
     *                  used for de-duplicating messages.
     * @param telemetry The telemetry measurements to send from the digital twin.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.sendTelemetry = function (id, messageId, telemetry, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, messageId: messageId, telemetry: telemetry, options: operationOptions }, sendTelemetryOperationSpec);
    };
    /**
     * Sends telemetry on behalf of a component in a digital twin.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id, message id, or component path is invalid.
     *   * ValidationFailed - The telemetry content is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     *   * ComponentNotFound - The component path was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param messageId A unique message identifier (in the scope of the digital twin id) that is commonly
     *                  used for de-duplicating messages.
     * @param telemetry The telemetry measurements to send from the digital twin's component.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.sendComponentTelemetry = function (id, componentPath, messageId, telemetry, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, componentPath: componentPath, messageId: messageId, telemetry: telemetry, options: operationOptions }, sendComponentTelemetryOperationSpec);
    };
    /**
     * Retrieves a component from a digital twin.
     * Status codes:
     * * 200 OK
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id or component path is invalid.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     *   * ComponentNotFound - The component path was not found.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.getComponent = function (id, componentPath, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, componentPath: componentPath, options: operationOptions }, getComponentOperationSpec);
    };
    /**
     * Updates a component on a digital twin.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * InvalidArgument - The digital twin id, component path, or payload is invalid.
     *   * JsonPatchInvalid - The JSON Patch provided is invalid.
     *   * ValidationFailed - Applying the patch results in an invalid digital twin.
     * * 404 Not Found
     *   * DigitalTwinNotFound - The digital twin was not found.
     * * 412 Precondition Failed
     *   * PreconditionFailed - The precondition check (If-Match or If-None-Match) failed.
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param componentPath The name of the DTDL component.
     * @param patchDocument An update specification described by JSON Patch. Updates to property values and
     *                      $model elements may happen in the same request. Operations are limited to add, replace and remove.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.updateComponent = function (id, componentPath, patchDocument, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, componentPath: componentPath, patchDocument: patchDocument, options: operationOptions }, updateComponentOperationSpec);
    };
    /**
     * ListRelationshipsNext
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param nextLink The nextLink from the previous successful call to the ListRelationships method.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.listRelationshipsNext = function (id, nextLink, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, nextLink: nextLink, options: operationOptions }, listRelationshipsNextOperationSpec);
    };
    /**
     * ListIncomingRelationshipsNext
     * @param id The id of the digital twin. The id is unique within the service and case sensitive.
     * @param nextLink The nextLink from the previous successful call to the ListIncomingRelationships
     *                 method.
     * @param options The options parameters.
     */
    DigitalTwins.prototype.listIncomingRelationshipsNext = function (id, nextLink, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, nextLink: nextLink, options: operationOptions }, listIncomingRelationshipsNextOperationSpec);
    };
    return DigitalTwins;
}());
// Operation Specifications
var serializer$2 = new coreHttp.Serializer(Mappers, /* isXml */ false);
var getByIdOperationSpec$1 = {
    path: "/digitaltwins/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } },
            headersMapper: DigitalTwinsGetByIdHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};
var addOperationSpec$1 = {
    path: "/digitaltwins/{id}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } },
            headersMapper: DigitalTwinsAddHeaders
        },
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: twin,
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [
        contentType,
        traceparent,
        tracestate,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
var deleteOperationSpec$1 = {
    path: "/digitaltwins/{id}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [
        traceparent,
        tracestate,
        ifMatch
    ],
    serializer: serializer$2
};
var updateOperationSpec$1 = {
    path: "/digitaltwins/{id}",
    httpMethod: "PATCH",
    responses: {
        202: {},
        204: {
            headersMapper: DigitalTwinsUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: patchDocument,
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [
        traceparent,
        tracestate,
        contentType1,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
var getRelationshipByIdOperationSpec = {
    path: "/digitaltwins/{id}/relationships/{relationshipId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } },
            headersMapper: DigitalTwinsGetRelationshipByIdHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id, relationshipId],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};
var addRelationshipOperationSpec = {
    path: "/digitaltwins/{id}/relationships/{relationshipId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } },
            headersMapper: DigitalTwinsAddRelationshipHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: relationship,
    queryParameters: [apiVersion],
    urlParameters: [$host, id, relationshipId],
    headerParameters: [
        contentType,
        traceparent,
        tracestate,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
var deleteRelationshipOperationSpec = {
    path: "/digitaltwins/{id}/relationships/{relationshipId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id, relationshipId],
    headerParameters: [
        traceparent,
        tracestate,
        ifMatch
    ],
    serializer: serializer$2
};
var updateRelationshipOperationSpec = {
    path: "/digitaltwins/{id}/relationships/{relationshipId}",
    httpMethod: "PATCH",
    responses: {
        204: {
            headersMapper: DigitalTwinsUpdateRelationshipHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: patchDocument,
    queryParameters: [apiVersion],
    urlParameters: [$host, id, relationshipId],
    headerParameters: [
        traceparent,
        tracestate,
        contentType1,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
var listRelationshipsOperationSpec = {
    path: "/digitaltwins/{id}/relationships",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, relationshipName],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};
var listIncomingRelationshipsOperationSpec = {
    path: "/digitaltwins/{id}/incomingrelationships",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IncomingRelationshipCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};
var sendTelemetryOperationSpec = {
    path: "/digitaltwins/{id}/telemetry",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: telemetry,
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [
        contentType,
        traceparent,
        tracestate,
        messageId,
        telemetrySourceTime
    ],
    mediaType: "json",
    serializer: serializer$2
};
var sendComponentTelemetryOperationSpec = {
    path: "/digitaltwins/{id}/components/{componentPath}/telemetry",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: telemetry,
    queryParameters: [apiVersion],
    urlParameters: [$host, id, componentPath],
    headerParameters: [
        contentType,
        traceparent,
        tracestate,
        messageId,
        telemetrySourceTime
    ],
    mediaType: "json",
    serializer: serializer$2
};
var getComponentOperationSpec = {
    path: "/digitaltwins/{id}/components/{componentPath}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } },
            headersMapper: DigitalTwinsGetComponentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id, componentPath],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};
var updateComponentOperationSpec = {
    path: "/digitaltwins/{id}/components/{componentPath}",
    httpMethod: "PATCH",
    responses: {
        202: {},
        204: {
            headersMapper: DigitalTwinsUpdateComponentHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: patchDocument,
    queryParameters: [apiVersion],
    urlParameters: [$host, id, componentPath],
    headerParameters: [
        traceparent,
        tracestate,
        contentType1,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$2
};
var listRelationshipsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, relationshipName],
    urlParameters: [$host, id, nextLink],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};
var listIncomingRelationshipsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IncomingRelationshipCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id, nextLink],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/**
 * Class representing a EventRoutes.
 */
var EventRoutes = /** @class */ (function () {
    /**
     * Initialize a new instance of the class EventRoutes class.
     * @param client Reference to the service client
     */
    function EventRoutes(client) {
        this.client = client;
    }
    /**
     * Retrieves all event routes.
     * Status codes:
     * * 200 OK
     * @param options The options parameters.
     */
    EventRoutes.prototype.list = function (options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ options: operationOptions }, listOperationSpec$1);
    };
    /**
     * Retrieves an event route.
     * Status codes:
     * * 200 OK
     * * 404 Not Found
     *   * EventRouteNotFound - The event route was not found.
     * @param id The id for an event route. The id is unique within event routes and case sensitive.
     * @param options The options parameters.
     */
    EventRoutes.prototype.getById = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, getByIdOperationSpec$2);
    };
    /**
     * Adds or replaces an event route.
     * Status codes:
     * * 204 No Content
     * * 400 Bad Request
     *   * EventRouteEndpointInvalid - The endpoint provided does not exist or is not active.
     *   * EventRouteFilterInvalid - The event route filter is invalid.
     *   * EventRouteIdInvalid - The event route id is invalid.
     *   * LimitExceeded - The maximum number of event routes allowed has been reached.
     * @param id The id for an event route. The id is unique within event routes and case sensitive.
     * @param options The options parameters.
     */
    EventRoutes.prototype.add = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, addOperationSpec$2);
    };
    /**
     * Deletes an event route.
     * Status codes:
     * * 204 No Content
     * * 404 Not Found
     *   * EventRouteNotFound - The event route was not found.
     * @param id The id for an event route. The id is unique within event routes and case sensitive.
     * @param options The options parameters.
     */
    EventRoutes.prototype.delete = function (id, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ id: id, options: operationOptions }, deleteOperationSpec$2);
    };
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    EventRoutes.prototype.listNext = function (nextLink, options) {
        var operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.client.sendOperationRequest({ nextLink: nextLink, options: operationOptions }, listNextOperationSpec$1);
    };
    return EventRoutes;
}());
// Operation Specifications
var serializer$3 = new coreHttp.Serializer(Mappers, /* isXml */ false);
var listOperationSpec$1 = {
    path: "/eventroutes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventRouteCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [
        traceparent,
        tracestate,
        maxItemsPerPage
    ],
    serializer: serializer$3
};
var getByIdOperationSpec$2 = {
    path: "/eventroutes/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventRoute
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$3
};
var addOperationSpec$2 = {
    path: "/eventroutes/{id}",
    httpMethod: "PUT",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: eventRoute,
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [
        contentType,
        traceparent,
        tracestate
    ],
    mediaType: "json",
    serializer: serializer$3
};
var deleteOperationSpec$2 = {
    path: "/eventroutes/{id}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, id],
    headerParameters: [traceparent, tracestate],
    serializer: serializer$3
};
var listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventRouteCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [
        traceparent,
        tracestate,
        maxItemsPerPage
    ],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var packageName = "@azure/digital-twins-core";
var packageVersion = "1.0.3";
var AzureDigitalTwinsAPIContext = /** @class */ (function (_super) {
    tslib.__extends(AzureDigitalTwinsAPIContext, _super);
    /**
     * Initializes a new instance of the AzureDigitalTwinsAPIContext class.
     * @param options The parameter options
     */
    function AzureDigitalTwinsAPIContext(options) {
        var _this = this;
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, undefined, options) || this;
        _this.requestContentType = "application/json; charset=utf-8";
        _this.baseUri =
            options.endpoint || "https://digitaltwins-name.digitaltwins.azure.net";
        // Assigning values to Constant parameters
        _this.$host =
            options.$host || "https://digitaltwins-name.digitaltwins.azure.net";
        _this.apiVersion = options.apiVersion || "2020-10-31";
        return _this;
    }
    return AzureDigitalTwinsAPIContext;
}(coreHttp.ServiceClient));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var AzureDigitalTwinsAPI = /** @class */ (function (_super) {
    tslib.__extends(AzureDigitalTwinsAPI, _super);
    /**
     * Initializes a new instance of the AzureDigitalTwinsAPI class.
     * @param options The parameter options
     */
    function AzureDigitalTwinsAPI(options) {
        var _this = _super.call(this, options) || this;
        _this.digitalTwinModels = new DigitalTwinModels(_this);
        _this.query = new Query(_this);
        _this.digitalTwins = new DigitalTwins(_this);
        _this.eventRoutes = new EventRoutes(_this);
        return _this;
    }
    return AzureDigitalTwinsAPI;
}(AzureDigitalTwinsAPIContext));

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 * @param name The name of the operation being performed.
 * @param tracingOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions) {
    var tracer = coreTracing.getTracer();
    var tracingOptions = operationOptions.tracingOptions || {};
    var spanOptions = tslib.__assign(tslib.__assign({}, tracingOptions.spanOptions), { kind: api.SpanKind.INTERNAL });
    var span = tracer.startSpan("DigitalTwinsClient." + operationName, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.DigitalTwins");
    var newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording()) {
        newSpanOptions = tslib.__assign(tslib.__assign({}, tracingOptions.spanOptions), { parent: span.context(), attributes: tslib.__assign(tslib.__assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.DigitalTwins" }) });
    }
    var newTracingOptions = tslib.__assign(tslib.__assign({}, tracingOptions), { spanOptions: newSpanOptions });
    var newOperationOptions = tslib.__assign(tslib.__assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
        span: span,
        updatedOptions: newOperationOptions
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
var logger = logger$1.createClientLogger("azure-digitaltwins-core");

// Copyright (c) Microsoft Corporation.
var SDK_VERSION = "1.0.3";
var DEFAULT_DIGITALTWINS_SCOPE = "https://digitaltwins.azure.net/.default";
/**
 * Client for Azure IoT DigitalTwins API.
 */
var DigitalTwinsClient = /** @class */ (function () {
    /**
     * Creates an instance of AzureDigitalTwinsAPI.
     *
     * Example usage:
     * ```ts
     * const { DigitalTwinsClient, ServiceClientCredentials } = require("@azure/digital-twins-core");
     *
     * const client = new DigitalTwinsClient(
     *   "<endpoint>",
     *   new DefaultAzureCredential();
     * );
     * ```
     * @param endpointUrl The endpoint URL of the service.
     * @param credential Used to authenticate requests to the service.
     * @param options Used to configure the service client.
     */
    function DigitalTwinsClient(endpointUrl, credential, options) {
        if (options === void 0) { options = {}; }
        var authPolicy = coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_DIGITALTWINS_SCOPE);
        var libInfo = "azsdk-js-digital-twins-core/" + SDK_VERSION;
        var apiVersion = options.apiVersion, pipelineOptions = tslib.__rest(options, ["apiVersion"]);
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        var internalPipelineOptions = tslib.__assign(tslib.__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-request-id"]
            }
        });
        var pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new AzureDigitalTwinsAPI(tslib.__assign({ endpoint: endpointUrl, apiVersion: apiVersion }, pipeline));
    }
    /**
     * Get a digital twin
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param options The operation options
     * @returns The application/json digital twin and the http response.
     */
    DigitalTwinsClient.prototype.getDigitalTwin = function (digitalTwinId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.getById(digitalTwinId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create or update a digital twin
     *
     * @param digitalTwinId The Id of the digital twin to create or update.
     * @param digitalTwinJson The application/json digital twin to create.
     * @param options Extended operation options including
     *  ifNoneMatch: Only perform the operation if the entity does not already exist.
     * @returns The created application/json digital twin and the http response.
     */
    DigitalTwinsClient.prototype.upsertDigitalTwin = function (digitalTwinId, digitalTwinJson, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-upsertDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            var payload = JSON.parse(digitalTwinJson);
            return this.client.digitalTwins.add(digitalTwinId, payload, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Update a digital twin using a json patch.
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param jsonPatch An update specification described by JSON Patch. Updates to property values
     * and $model elements may happen in the same request. Operations are limited to add, replace and
     * remove.
     * @param options Extended operation options including
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.updateDigitalTwin = function (digitalTwinId, jsonPatch, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-updateDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.update(digitalTwinId, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete a digital twin
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param options Extended operation options including
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteDigitalTwin = function (digitalTwinId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.delete(digitalTwinId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get a component on a digital twin.
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param componentName The component being retrieved.
     * @param options The operation options
     * @returns Json string representation of the component corresponding to the provided componentName and the HTTP response.
     */
    DigitalTwinsClient.prototype.getComponent = function (digitalTwinId, componentName, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getComponent", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.getComponent(digitalTwinId, componentName, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Update properties of a component on a digital twin using a JSON patch.
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param componentName The component being updated.
     * @param jsonPatch The application/json-patch+json operations to be performed on the specified digital twin's component.
     * @param enableUpdate If true then update of an existing digital twin is enabled.
     * @param options Extended operation options including
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.updateComponent = function (digitalTwinId, componentName, jsonPatch, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-updateComponent", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.updateComponent(digitalTwinId, componentName, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get a relationship on a digital twin.
     *
     * @param digitalTwinId The Id of the source digital twin.
     * @param relationshipId The Id of the relationship to retrieve.
     * @param options The operation options
     * @returns The pageable list of application/json relationships belonging to the specified digital twin and the http response.
     */
    DigitalTwinsClient.prototype.getRelationship = function (digitalTwinId, relationshipId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.getRelationshipById(digitalTwinId, relationshipId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create or update a relationship on a digital twin.
     *
     * @param digitalTwinId The Id of the source digital twin.
     * @param relationshipId The Id of the relationship to create.
     * @param relationship: The application/json relationship to be created.
     * @param options Extended operation options including
     *  ifNoneMatch: Only perform the operation if the entity does not already exist.
     */
    DigitalTwinsClient.prototype.upsertRelationship = function (digitalTwinId, relationshipId, relationship, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-upsertRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.addRelationship(digitalTwinId, relationshipId, relationship, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Updates the properties of a relationship on a digital twin using a JSON patch.
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param relationshipId The Id of the relationship to be updated.
     * @param jsonPatch The application/json-patch+json operations to be performed on the specified digital twin's relationship.
     * @param options Extended operation options
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     */
    DigitalTwinsClient.prototype.updateRelationship = function (digitalTwinId, relationshipId, jsonPatch, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-updateRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.updateRelationship(digitalTwinId, relationshipId, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete a relationship on a digital twin.
     *
     * @param digitalTwinId The Id of the source digital twin.
     * @param relationshipId The Id of the relationship to delete.
     * @param options The operation options
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteRelationship = function (digitalTwinId, relationshipId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.deleteRelationship(digitalTwinId, relationshipId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link listRelationships}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {DigitalTwinsListRelationshipsOptionalParams} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.listRelationshipsPage = function (digitalTwinId, options, continuationState) {
        return tslib.__asyncGenerator(this, arguments, function listRelationshipsPage_1() {
            var optionsComplete, listRelationshipResponse, listRelationshipResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({}, options);
                        return [4 /*yield*/, tslib.__await(this.client.digitalTwins.listRelationships(digitalTwinId, optionsComplete))];
                    case 1:
                        listRelationshipResponse = _a.sent();
                        continuationState.continuationToken = listRelationshipResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listRelationshipResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(this.client.digitalTwins.listRelationshipsNext("", continuationState.continuationToken, options))];
                    case 5:
                        listRelationshipResponse = _a.sent();
                        continuationState.continuationToken = listRelationshipResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listRelationshipResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link listRelationships}.
     * @param {DigitalTwinsListRelationshipsOptionalParams} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.listRelationshipsAll = function (digitalTwinId, options) {
        return tslib.__asyncGenerator(this, arguments, function listRelationshipsAll_1() {
            var _a, _b, page, value, _i, value_1, item, e_1_1;
            var e_1, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 9, 10, 15]);
                        _a = tslib.__asyncValues(this.listRelationshipsPage(digitalTwinId, options, {}));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 8];
                        page = _b.value;
                        value = page.value || [];
                        _i = 0, value_1 = value;
                        _d.label = 3;
                    case 3:
                        if (!(_i < value_1.length)) return [3 /*break*/, 7];
                        item = value_1[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 4: return [4 /*yield*/, _d.sent()];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _d.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 11:
                        _d.sent();
                        _d.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve relationships for a digital twin.
     *
     * @param digitalTwinId The Id of the digital twin.
     */
    DigitalTwinsClient.prototype.listRelationships = function (digitalTwinId, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var _b = createSpan("DigitalTwinsClient-listRelationships", options), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_1 = this.listRelationshipsAll(digitalTwinId, updatedOptions);
            return _a = {
                    next: function () {
                        return iter_1.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listRelationshipsPage(digitalTwinId, updatedOptions, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link listIncomingRelationships}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.listIncomingRelationshipsPage = function (digitalTwinId, options, continuationState) {
        return tslib.__asyncGenerator(this, arguments, function listIncomingRelationshipsPage_1() {
            var optionsComplete, listIncomingRelationshipsResponse, listIncomingRelationshipsResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({}, options);
                        return [4 /*yield*/, tslib.__await(this.client.digitalTwins.listIncomingRelationships(digitalTwinId, optionsComplete))];
                    case 1:
                        listIncomingRelationshipsResponse = _a.sent();
                        continuationState.continuationToken = listIncomingRelationshipsResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listIncomingRelationshipsResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(this.client.digitalTwins.listIncomingRelationshipsNext("", continuationState.continuationToken, options))];
                    case 5:
                        listIncomingRelationshipsResponse = _a.sent();
                        continuationState.continuationToken = listIncomingRelationshipsResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listIncomingRelationshipsResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link listIncomingRelationships}.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.listIncomingRelationshipsAll = function (digitalTwinId, options) {
        return tslib.__asyncGenerator(this, arguments, function listIncomingRelationshipsAll_1() {
            var _a, _b, page, value, e_2_1;
            var e_2, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        _a = tslib.__asyncValues(this.listIncomingRelationshipsPage(digitalTwinId, options, {}));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 6];
                        page = _b.value;
                        value = page.value || [];
                        return [5 /*yield**/, tslib.__values(tslib.__asyncDelegator(tslib.__asyncValues(value)))];
                    case 3: return [4 /*yield*/, tslib.__await.apply(void 0, [_d.sent()])];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve all incoming relationships for a digital twin.
     *
     * @param digitalTwinId The Id of the digital twin.
     */
    DigitalTwinsClient.prototype.listIncomingRelationships = function (digitalTwinId, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var _b = createSpan("DigitalTwinsClient-listIncomingRelationships", options), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_2 = this.listIncomingRelationshipsAll(digitalTwinId, updatedOptions);
            return _a = {
                    next: function () {
                        return iter_2.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listIncomingRelationshipsPage(digitalTwinId, updatedOptions, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Publish telemetry from a digital twin, which is then consumed by one or many destination endpoints (subscribers) defined under.
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param payload The application/json telemetry payload to be sent.
     * @param messageId The message Id.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.publishTelemetry = function (digitalTwinId, payload, messageId, options) {
        if (options === void 0) { options = {}; }
        var digitalTwinsSendTelemetryOptionalParams = options;
        digitalTwinsSendTelemetryOptionalParams.telemetrySourceTime = new Date().toISOString();
        if (!messageId) {
            messageId = coreHttp.generateUuid();
        }
        var _a = createSpan("DigitalTwinsClient-publishTelemetry", digitalTwinsSendTelemetryOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.sendTelemetry(digitalTwinId, payload, messageId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Publish telemetry from a digital twin's component, which is then consumed by one or many destination endpoints (subscribers) defined under.
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param componentName The name of the DTDL component.
     * @param payload The application/json telemetry payload to be sent.
     * @param messageId The message Id.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.publishComponentTelemetry = function (digitalTwinId, componentName, payload, messageId, options) {
        if (options === void 0) { options = {}; }
        var digitalTwinsSendComponentTelemetryOptionalParams = options;
        digitalTwinsSendComponentTelemetryOptionalParams.telemetrySourceTime = new Date().toISOString();
        if (!messageId) {
            messageId = coreHttp.generateUuid();
        }
        var _a = createSpan("DigitalTwinsClient-publishComponentTelemetry", digitalTwinsSendComponentTelemetryOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.sendComponentTelemetry(digitalTwinId, componentName, payload, messageId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get a model, including the model metadata and the model definition.
     *
     * @param modelId The Id of the model.
     * @param options Extended operation options including
     *  includeModelDefinition: When true the model definition will be returned as part of the result. Default value: false.
     * @returns The application/json model and the http response.
     */
    DigitalTwinsClient.prototype.getModel = function (modelId, includeModelDefinition, options) {
        if (includeModelDefinition === void 0) { includeModelDefinition = false; }
        if (options === void 0) { options = {}; }
        var digitalTwinModelsGetByIdOptionalParams = options;
        digitalTwinModelsGetByIdOptionalParams.includeModelDefinition = includeModelDefinition;
        var _a = createSpan("DigitalTwinsClient-getModel", digitalTwinModelsGetByIdOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.getById(modelId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link list}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {DigitalTwinModelsListOptionalParams} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.getModelsPage = function (options, continuationState) {
        return tslib.__asyncGenerator(this, arguments, function getModelsPage_1() {
            var optionsComplete, listResponse, listResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = options;
                        optionsComplete.maxItemsPerPage = continuationState.maxPageSize;
                        return [4 /*yield*/, tslib.__await(this.client.digitalTwinModels.list(optionsComplete))];
                    case 1:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(this.client.digitalTwinModels.listNext(continuationState.continuationToken, options))];
                    case 5:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link list}.
     * @param {DigitalTwinModelsListOptionalParams} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.getModelsAll = function (options) {
        return tslib.__asyncGenerator(this, arguments, function getModelsAll_1() {
            var f, _a, _b, page, value, _i, value_2, item, e_3_1;
            var e_3, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.getModelsPage(options, f));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        value = page.value || [];
                        _i = 0, value_2 = value;
                        _d.label = 4;
                    case 4:
                        if (!(_i < value_2.length)) return [3 /*break*/, 8];
                        item = value_2[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the list of models
     *
     * @param dependeciesFor The model Ids to have dependencies retrieved. If omitted, all models are retrieved.
     * @param includeModelDefinition Whether to include the model definition in the result. If false, only the model metadata will be returned.
     * @param resultsPerPage The maximum number of items to retrieve per request. The server may choose to return less than the requested max.
     * @returns A pageable set of application/json models and the http response.
     */
    DigitalTwinsClient.prototype.listModels = function (dependeciesFor, includeModelDefinition, resultsPerPage, options) {
        var _a;
        var _this = this;
        if (includeModelDefinition === void 0) { includeModelDefinition = false; }
        if (options === void 0) { options = {}; }
        var digitalTwinModelsListOptionalParams = options;
        digitalTwinModelsListOptionalParams = {
            maxItemsPerPage: resultsPerPage,
            dependenciesFor: dependeciesFor,
            includeModelDefinition: includeModelDefinition
        };
        var _b = createSpan("DigitalTwinsClient-listModels", digitalTwinModelsListOptionalParams), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_3 = this.getModelsAll(updatedOptions);
            return _a = {
                    next: function () {
                        return iter_3.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.getModelsPage(digitalTwinModelsListOptionalParams, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create one or many
     *
     * @param models The set of models to create. Each string corresponds to exactly one model.
     * @param options The operation options
     * @returns The created application/json models and the http response.
     */
    DigitalTwinsClient.prototype.createModels = function (dtdlModels, options) {
        if (options === void 0) { options = {}; }
        var digitalTwinModelsAddOptionalParams = options;
        digitalTwinModelsAddOptionalParams.models = dtdlModels;
        var _a = createSpan("DigitalTwinsClient-createModels", digitalTwinModelsAddOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.add(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Decommission a model using a json patch.
     *
     * @param modelId The Id of the model to decommission.
     * property can be replaced.
     * @param options The operation options
     * @returns The http response.
     * @summary When a model is decomissioned, new digital twins will no longer be able to be
     * defined by this model. However, existing digital twins may continue to use this model.
     * Once a model is decomissioned, it may not be recommissioned.
     */
    DigitalTwinsClient.prototype.decomissionModel = function (modelId, options) {
        if (options === void 0) { options = {}; }
        var jsonPatch = [{ op: "replace", path: "/decommissioned", value: true }];
        var _a = createSpan("DigitalTwinsClient-decomissionModel", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.update(modelId, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete a model.
     *
     * @param modelId The Id of the model to delete.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteModel = function (modelId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteModel", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.delete(modelId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get an event route.
     *
     * @param modelId The Id of the event route.
     * @param options The operation options
     * @returns The application/json event route and the http response.
     */
    DigitalTwinsClient.prototype.getEventRoute = function (eventRouteId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getEventRoute", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.eventRoutes.getById(eventRouteId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link list}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {EventRoutesListOptionalParams} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.getEventRoutesPage = function (options, continuationState) {
        return tslib.__asyncGenerator(this, arguments, function getEventRoutesPage_1() {
            var optionsComplete, listResponse, listResponse;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = options;
                        optionsComplete.maxItemsPerPage = continuationState.maxPageSize;
                        return [4 /*yield*/, tslib.__await(this.client.eventRoutes.list(optionsComplete))];
                    case 1:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(this.client.eventRoutes.listNext(continuationState.continuationToken, options))];
                    case 5:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, tslib.__await(listResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link list}.
     * @param {EventRoutesListOptionalParams} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.getEventRoutesAll = function (options) {
        return tslib.__asyncGenerator(this, arguments, function getEventRoutesAll_1() {
            var f, _a, _b, page, value, _i, value_3, item, e_4_1;
            var e_4, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.getEventRoutesPage(options, f));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        value = page.value || [];
                        _i = 0, value_3 = value;
                        _d.label = 4;
                    case 4:
                        if (!(_i < value_3.length)) return [3 /*break*/, 8];
                        item = value_3[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_4_1 = _d.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_4) throw e_4.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * List the event routes in a digital twins instance.
     *
     * @param resultsPerPage The maximum number of items to retrieve per request. The server may choose to return less than
     * the requested max.
     * @returns The application/json event route and the http response.
     */
    DigitalTwinsClient.prototype.listEventRoutes = function (resultsPerPage, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var eventRoutesListOptionalParams = options;
        eventRoutesListOptionalParams = {
            maxItemsPerPage: resultsPerPage
        };
        var _b = createSpan("DigitalTwinsClient-listEventRoutes", eventRoutesListOptionalParams), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_4 = this.getEventRoutesAll(updatedOptions);
            return _a = {
                    next: function () {
                        return iter_4.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.getEventRoutesPage(eventRoutesListOptionalParams, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create or update an event route.
     *
     * @param eventRouteId The Id of the event route to create or update.
     * @param endpointId The id of the endpoint this event route is bound to.
     * @param filter An expression which describes the events which are routed to the endpoint.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.upsertEventRoute = function (eventRouteId, endpointId, filter, options) {
        if (options === void 0) { options = {}; }
        var eventRoutesAddOptionalParams = options;
        var eventRoute = {
            endpointName: endpointId,
            filter: filter
        };
        eventRoutesAddOptionalParams.eventRoute = eventRoute;
        var _a = createSpan("DigitalTwinsClient-upsertEventRoute", eventRoutesAddOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.eventRoutes.add(eventRouteId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete an event route.
     *
     * @param eventRouteId The Id of the eventRoute to delete.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteEventRoute = function (eventRouteId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteEventRoute", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.eventRoutes.delete(eventRouteId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link query}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.queryTwinsPage = function (query, options, continuationState) {
        return tslib.__asyncGenerator(this, arguments, function queryTwinsPage_1() {
            var querySpecification, queryResult, querySpecification, queryResult;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        querySpecification = {
                            query: query,
                            continuationToken: continuationState.continuationToken
                        };
                        return [4 /*yield*/, tslib.__await(this.client.query.queryTwins(querySpecification, options))];
                    case 1:
                        queryResult = _a.sent();
                        continuationState.continuationToken = queryResult.continuationToken;
                        return [4 /*yield*/, tslib.__await(queryResult)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        querySpecification = {
                            query: query,
                            continuationToken: continuationState.continuationToken
                        };
                        return [4 /*yield*/, tslib.__await(this.client.query.queryTwins(querySpecification, options))];
                    case 5:
                        queryResult = _a.sent();
                        continuationState.continuationToken = queryResult.continuationToken;
                        return [4 /*yield*/, tslib.__await(queryResult)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link query}.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.queryTwinsAll = function (query, options) {
        return tslib.__asyncGenerator(this, arguments, function queryTwinsAll_1() {
            var f, _a, _b, page, _i, _c, item, e_5_1;
            var e_5, _d;
            return tslib.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        f = {};
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.queryTwinsPage(query, options, f));
                        _e.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        if (!page.value) return [3 /*break*/, 8];
                        _i = 0, _c = page.value;
                        _e.label = 4;
                    case 4:
                        if (!(_i < _c.length)) return [3 /*break*/, 8];
                        item = _c[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _e.sent()];
                    case 6:
                        _e.sent();
                        _e.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_5_1 = _e.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _e.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_d.call(_a))];
                    case 12:
                        _e.sent();
                        _e.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Query for digital twins.
     *
     * @param query The query string, in SQL-like syntax.
     * @param resultsPerPage The maximum number of items to retrieve per request. The server may choose to return less than the requested max.
     * @returns The pageable list of query results.
     */
    DigitalTwinsClient.prototype.queryTwins = function (query, resultsPerPage, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var queryQueryTwinsOptionalParams = options;
        queryQueryTwinsOptionalParams = {
            maxItemsPerPage: resultsPerPage
        };
        var _b = createSpan("DigitalTwinsClient-queryTwins", queryQueryTwinsOptionalParams), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_5 = this.queryTwinsAll(query, updatedOptions);
            return _a = {
                    next: function () {
                        return iter_5.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.queryTwinsPage(query, queryQueryTwinsOptionalParams, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    return DigitalTwinsClient;
}());

exports.DigitalTwinsClient = DigitalTwinsClient;
//# sourceMappingURL=index.js.map
