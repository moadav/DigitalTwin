// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __assign, __asyncDelegator, __asyncGenerator, __asyncValues, __await, __generator, __rest, __values } from "tslib";
/// <reference lib="esnext.asynciterable" />
import { bearerTokenAuthenticationPolicy, createPipelineFromOptions, generateUuid } from "@azure/core-http";
import { AzureDigitalTwinsAPI as GeneratedClient } from "./generated/azureDigitalTwinsAPI";
import { createSpan } from "./tracing";
import { CanonicalCode } from "@opentelemetry/api";
import { logger } from "./logger";
export var SDK_VERSION = "1.0.3";
var DEFAULT_DIGITALTWINS_SCOPE = "https://digitaltwins.azure.net/.default";
/**
 * Client for Azure IoT DigitalTwins API.
 */
var DigitalTwinsClient = /** @class */ (function () {
    /**
     * Creates an instance of AzureDigitalTwinsAPI.
     *
     * Example usage:
     * ```ts
     * const { DigitalTwinsClient, ServiceClientCredentials } = require("@azure/digital-twins-core");
     *
     * const client = new DigitalTwinsClient(
     *   "<endpoint>",
     *   new DefaultAzureCredential();
     * );
     * ```
     * @param endpointUrl The endpoint URL of the service.
     * @param credential Used to authenticate requests to the service.
     * @param options Used to configure the service client.
     */
    function DigitalTwinsClient(endpointUrl, credential, options) {
        if (options === void 0) { options = {}; }
        var authPolicy = bearerTokenAuthenticationPolicy(credential, DEFAULT_DIGITALTWINS_SCOPE);
        var libInfo = "azsdk-js-digital-twins-core/" + SDK_VERSION;
        var apiVersion = options.apiVersion, pipelineOptions = __rest(options, ["apiVersion"]);
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        var internalPipelineOptions = __assign(__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-request-id"]
            }
        });
        var pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(__assign({ endpoint: endpointUrl, apiVersion: apiVersion }, pipeline));
    }
    /**
     * Get a digital twin
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param options The operation options
     * @returns The application/json digital twin and the http response.
     */
    DigitalTwinsClient.prototype.getDigitalTwin = function (digitalTwinId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.getById(digitalTwinId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create or update a digital twin
     *
     * @param digitalTwinId The Id of the digital twin to create or update.
     * @param digitalTwinJson The application/json digital twin to create.
     * @param options Extended operation options including
     *  ifNoneMatch: Only perform the operation if the entity does not already exist.
     * @returns The created application/json digital twin and the http response.
     */
    DigitalTwinsClient.prototype.upsertDigitalTwin = function (digitalTwinId, digitalTwinJson, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-upsertDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            var payload = JSON.parse(digitalTwinJson);
            return this.client.digitalTwins.add(digitalTwinId, payload, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Update a digital twin using a json patch.
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param jsonPatch An update specification described by JSON Patch. Updates to property values
     * and $model elements may happen in the same request. Operations are limited to add, replace and
     * remove.
     * @param options Extended operation options including
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.updateDigitalTwin = function (digitalTwinId, jsonPatch, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-updateDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.update(digitalTwinId, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete a digital twin
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param options Extended operation options including
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteDigitalTwin = function (digitalTwinId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteDigitalTwin", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.delete(digitalTwinId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get a component on a digital twin.
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param componentName The component being retrieved.
     * @param options The operation options
     * @returns Json string representation of the component corresponding to the provided componentName and the HTTP response.
     */
    DigitalTwinsClient.prototype.getComponent = function (digitalTwinId, componentName, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getComponent", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.getComponent(digitalTwinId, componentName, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Update properties of a component on a digital twin using a JSON patch.
     *
     * @param digitalTwinId The Id of the digital twin.
     * @param componentName The component being updated.
     * @param jsonPatch The application/json-patch+json operations to be performed on the specified digital twin's component.
     * @param enableUpdate If true then update of an existing digital twin is enabled.
     * @param options Extended operation options including
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.updateComponent = function (digitalTwinId, componentName, jsonPatch, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-updateComponent", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.updateComponent(digitalTwinId, componentName, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get a relationship on a digital twin.
     *
     * @param digitalTwinId The Id of the source digital twin.
     * @param relationshipId The Id of the relationship to retrieve.
     * @param options The operation options
     * @returns The pageable list of application/json relationships belonging to the specified digital twin and the http response.
     */
    DigitalTwinsClient.prototype.getRelationship = function (digitalTwinId, relationshipId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.getRelationshipById(digitalTwinId, relationshipId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create or update a relationship on a digital twin.
     *
     * @param digitalTwinId The Id of the source digital twin.
     * @param relationshipId The Id of the relationship to create.
     * @param relationship: The application/json relationship to be created.
     * @param options Extended operation options including
     *  ifNoneMatch: Only perform the operation if the entity does not already exist.
     */
    DigitalTwinsClient.prototype.upsertRelationship = function (digitalTwinId, relationshipId, relationship, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-upsertRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.addRelationship(digitalTwinId, relationshipId, relationship, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Updates the properties of a relationship on a digital twin using a JSON patch.
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param relationshipId The Id of the relationship to be updated.
     * @param jsonPatch The application/json-patch+json operations to be performed on the specified digital twin's relationship.
     * @param options Extended operation options
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is provided.
     */
    DigitalTwinsClient.prototype.updateRelationship = function (digitalTwinId, relationshipId, jsonPatch, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-updateRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.updateRelationship(digitalTwinId, relationshipId, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete a relationship on a digital twin.
     *
     * @param digitalTwinId The Id of the source digital twin.
     * @param relationshipId The Id of the relationship to delete.
     * @param options The operation options
     *   ifMatch: Only perform the operation if the entity's etag matches one of the etags provided or * is
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteRelationship = function (digitalTwinId, relationshipId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteRelationship", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.deleteRelationship(digitalTwinId, relationshipId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link listRelationships}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {DigitalTwinsListRelationshipsOptionalParams} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.listRelationshipsPage = function (digitalTwinId, options, continuationState) {
        return __asyncGenerator(this, arguments, function listRelationshipsPage_1() {
            var optionsComplete, listRelationshipResponse, listRelationshipResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({}, options);
                        return [4 /*yield*/, __await(this.client.digitalTwins.listRelationships(digitalTwinId, optionsComplete))];
                    case 1:
                        listRelationshipResponse = _a.sent();
                        continuationState.continuationToken = listRelationshipResponse.nextLink;
                        return [4 /*yield*/, __await(listRelationshipResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.digitalTwins.listRelationshipsNext("", continuationState.continuationToken, options))];
                    case 5:
                        listRelationshipResponse = _a.sent();
                        continuationState.continuationToken = listRelationshipResponse.nextLink;
                        return [4 /*yield*/, __await(listRelationshipResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link listRelationships}.
     * @param {DigitalTwinsListRelationshipsOptionalParams} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.listRelationshipsAll = function (digitalTwinId, options) {
        return __asyncGenerator(this, arguments, function listRelationshipsAll_1() {
            var _a, _b, page, value, _i, value_1, item, e_1_1;
            var e_1, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 9, 10, 15]);
                        _a = __asyncValues(this.listRelationshipsPage(digitalTwinId, options, {}));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 8];
                        page = _b.value;
                        value = page.value || [];
                        _i = 0, value_1 = value;
                        _d.label = 3;
                    case 3:
                        if (!(_i < value_1.length)) return [3 /*break*/, 7];
                        item = value_1[_i];
                        return [4 /*yield*/, __await(item)];
                    case 4: return [4 /*yield*/, _d.sent()];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _d.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 11:
                        _d.sent();
                        _d.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve relationships for a digital twin.
     *
     * @param digitalTwinId The Id of the digital twin.
     */
    DigitalTwinsClient.prototype.listRelationships = function (digitalTwinId, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var _b = createSpan("DigitalTwinsClient-listRelationships", options), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_1 = this.listRelationshipsAll(digitalTwinId, updatedOptions);
            return _a = {
                    next: function () {
                        return iter_1.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listRelationshipsPage(digitalTwinId, updatedOptions, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link listIncomingRelationships}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.listIncomingRelationshipsPage = function (digitalTwinId, options, continuationState) {
        return __asyncGenerator(this, arguments, function listIncomingRelationshipsPage_1() {
            var optionsComplete, listIncomingRelationshipsResponse, listIncomingRelationshipsResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = __assign({}, options);
                        return [4 /*yield*/, __await(this.client.digitalTwins.listIncomingRelationships(digitalTwinId, optionsComplete))];
                    case 1:
                        listIncomingRelationshipsResponse = _a.sent();
                        continuationState.continuationToken = listIncomingRelationshipsResponse.nextLink;
                        return [4 /*yield*/, __await(listIncomingRelationshipsResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.digitalTwins.listIncomingRelationshipsNext("", continuationState.continuationToken, options))];
                    case 5:
                        listIncomingRelationshipsResponse = _a.sent();
                        continuationState.continuationToken = listIncomingRelationshipsResponse.nextLink;
                        return [4 /*yield*/, __await(listIncomingRelationshipsResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link listIncomingRelationships}.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.listIncomingRelationshipsAll = function (digitalTwinId, options) {
        return __asyncGenerator(this, arguments, function listIncomingRelationshipsAll_1() {
            var _a, _b, page, value, e_2_1;
            var e_2, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        _a = __asyncValues(this.listIncomingRelationshipsPage(digitalTwinId, options, {}));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 6];
                        page = _b.value;
                        value = page.value || [];
                        return [5 /*yield**/, __values(__asyncDelegator(__asyncValues(value)))];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_d.sent()])];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve all incoming relationships for a digital twin.
     *
     * @param digitalTwinId The Id of the digital twin.
     */
    DigitalTwinsClient.prototype.listIncomingRelationships = function (digitalTwinId, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var _b = createSpan("DigitalTwinsClient-listIncomingRelationships", options), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_2 = this.listIncomingRelationshipsAll(digitalTwinId, updatedOptions);
            return _a = {
                    next: function () {
                        return iter_2.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.listIncomingRelationshipsPage(digitalTwinId, updatedOptions, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Publish telemetry from a digital twin, which is then consumed by one or many destination endpoints (subscribers) defined under.
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param payload The application/json telemetry payload to be sent.
     * @param messageId The message Id.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.publishTelemetry = function (digitalTwinId, payload, messageId, options) {
        if (options === void 0) { options = {}; }
        var digitalTwinsSendTelemetryOptionalParams = options;
        digitalTwinsSendTelemetryOptionalParams.telemetrySourceTime = new Date().toISOString();
        if (!messageId) {
            messageId = generateUuid();
        }
        var _a = createSpan("DigitalTwinsClient-publishTelemetry", digitalTwinsSendTelemetryOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.sendTelemetry(digitalTwinId, payload, messageId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Publish telemetry from a digital twin's component, which is then consumed by one or many destination endpoints (subscribers) defined under.
     *
     * @param digitalTwinId The Id of the digital twin to delete.
     * @param componentName The name of the DTDL component.
     * @param payload The application/json telemetry payload to be sent.
     * @param messageId The message Id.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.publishComponentTelemetry = function (digitalTwinId, componentName, payload, messageId, options) {
        if (options === void 0) { options = {}; }
        var digitalTwinsSendComponentTelemetryOptionalParams = options;
        digitalTwinsSendComponentTelemetryOptionalParams.telemetrySourceTime = new Date().toISOString();
        if (!messageId) {
            messageId = generateUuid();
        }
        var _a = createSpan("DigitalTwinsClient-publishComponentTelemetry", digitalTwinsSendComponentTelemetryOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwins.sendComponentTelemetry(digitalTwinId, componentName, payload, messageId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get a model, including the model metadata and the model definition.
     *
     * @param modelId The Id of the model.
     * @param options Extended operation options including
     *  includeModelDefinition: When true the model definition will be returned as part of the result. Default value: false.
     * @returns The application/json model and the http response.
     */
    DigitalTwinsClient.prototype.getModel = function (modelId, includeModelDefinition, options) {
        if (includeModelDefinition === void 0) { includeModelDefinition = false; }
        if (options === void 0) { options = {}; }
        var digitalTwinModelsGetByIdOptionalParams = options;
        digitalTwinModelsGetByIdOptionalParams.includeModelDefinition = includeModelDefinition;
        var _a = createSpan("DigitalTwinsClient-getModel", digitalTwinModelsGetByIdOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.getById(modelId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link list}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {DigitalTwinModelsListOptionalParams} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.getModelsPage = function (options, continuationState) {
        return __asyncGenerator(this, arguments, function getModelsPage_1() {
            var optionsComplete, listResponse, listResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = options;
                        optionsComplete.maxItemsPerPage = continuationState.maxPageSize;
                        return [4 /*yield*/, __await(this.client.digitalTwinModels.list(optionsComplete))];
                    case 1:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, __await(listResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.digitalTwinModels.listNext(continuationState.continuationToken, options))];
                    case 5:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, __await(listResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link list}.
     * @param {DigitalTwinModelsListOptionalParams} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.getModelsAll = function (options) {
        return __asyncGenerator(this, arguments, function getModelsAll_1() {
            var f, _a, _b, page, value, _i, value_2, item, e_3_1;
            var e_3, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.getModelsPage(options, f));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        value = page.value || [];
                        _i = 0, value_2 = value;
                        _d.label = 4;
                    case 4:
                        if (!(_i < value_2.length)) return [3 /*break*/, 8];
                        item = value_2[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the list of models
     *
     * @param dependeciesFor The model Ids to have dependencies retrieved. If omitted, all models are retrieved.
     * @param includeModelDefinition Whether to include the model definition in the result. If false, only the model metadata will be returned.
     * @param resultsPerPage The maximum number of items to retrieve per request. The server may choose to return less than the requested max.
     * @returns A pageable set of application/json models and the http response.
     */
    DigitalTwinsClient.prototype.listModels = function (dependeciesFor, includeModelDefinition, resultsPerPage, options) {
        var _a;
        var _this = this;
        if (includeModelDefinition === void 0) { includeModelDefinition = false; }
        if (options === void 0) { options = {}; }
        var digitalTwinModelsListOptionalParams = options;
        digitalTwinModelsListOptionalParams = {
            maxItemsPerPage: resultsPerPage,
            dependenciesFor: dependeciesFor,
            includeModelDefinition: includeModelDefinition
        };
        var _b = createSpan("DigitalTwinsClient-listModels", digitalTwinModelsListOptionalParams), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_3 = this.getModelsAll(updatedOptions);
            return _a = {
                    next: function () {
                        return iter_3.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.getModelsPage(digitalTwinModelsListOptionalParams, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create one or many
     *
     * @param models The set of models to create. Each string corresponds to exactly one model.
     * @param options The operation options
     * @returns The created application/json models and the http response.
     */
    DigitalTwinsClient.prototype.createModels = function (dtdlModels, options) {
        if (options === void 0) { options = {}; }
        var digitalTwinModelsAddOptionalParams = options;
        digitalTwinModelsAddOptionalParams.models = dtdlModels;
        var _a = createSpan("DigitalTwinsClient-createModels", digitalTwinModelsAddOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.add(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Decommission a model using a json patch.
     *
     * @param modelId The Id of the model to decommission.
     * property can be replaced.
     * @param options The operation options
     * @returns The http response.
     * @summary When a model is decomissioned, new digital twins will no longer be able to be
     * defined by this model. However, existing digital twins may continue to use this model.
     * Once a model is decomissioned, it may not be recommissioned.
     */
    DigitalTwinsClient.prototype.decomissionModel = function (modelId, options) {
        if (options === void 0) { options = {}; }
        var jsonPatch = [{ op: "replace", path: "/decommissioned", value: true }];
        var _a = createSpan("DigitalTwinsClient-decomissionModel", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.update(modelId, jsonPatch, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete a model.
     *
     * @param modelId The Id of the model to delete.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteModel = function (modelId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteModel", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.digitalTwinModels.delete(modelId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Get an event route.
     *
     * @param modelId The Id of the event route.
     * @param options The operation options
     * @returns The application/json event route and the http response.
     */
    DigitalTwinsClient.prototype.getEventRoute = function (eventRouteId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-getEventRoute", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.eventRoutes.getById(eventRouteId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link list}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {EventRoutesListOptionalParams} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.getEventRoutesPage = function (options, continuationState) {
        return __asyncGenerator(this, arguments, function getEventRoutesPage_1() {
            var optionsComplete, listResponse, listResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = options;
                        optionsComplete.maxItemsPerPage = continuationState.maxPageSize;
                        return [4 /*yield*/, __await(this.client.eventRoutes.list(optionsComplete))];
                    case 1:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, __await(listResponse)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(this.client.eventRoutes.listNext(continuationState.continuationToken, options))];
                    case 5:
                        listResponse = _a.sent();
                        continuationState.continuationToken = listResponse.nextLink;
                        return [4 /*yield*/, __await(listResponse)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link list}.
     * @param {EventRoutesListOptionalParams} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.getEventRoutesAll = function (options) {
        return __asyncGenerator(this, arguments, function getEventRoutesAll_1() {
            var f, _a, _b, page, value, _i, value_3, item, e_4_1;
            var e_4, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.getEventRoutesPage(options, f));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        value = page.value || [];
                        _i = 0, value_3 = value;
                        _d.label = 4;
                    case 4:
                        if (!(_i < value_3.length)) return [3 /*break*/, 8];
                        item = value_3[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_4_1 = _d.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_4) throw e_4.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * List the event routes in a digital twins instance.
     *
     * @param resultsPerPage The maximum number of items to retrieve per request. The server may choose to return less than
     * the requested max.
     * @returns The application/json event route and the http response.
     */
    DigitalTwinsClient.prototype.listEventRoutes = function (resultsPerPage, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var eventRoutesListOptionalParams = options;
        eventRoutesListOptionalParams = {
            maxItemsPerPage: resultsPerPage
        };
        var _b = createSpan("DigitalTwinsClient-listEventRoutes", eventRoutesListOptionalParams), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_4 = this.getEventRoutesAll(updatedOptions);
            return _a = {
                    next: function () {
                        return iter_4.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.getEventRoutesPage(eventRoutesListOptionalParams, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Create or update an event route.
     *
     * @param eventRouteId The Id of the event route to create or update.
     * @param endpointId The id of the endpoint this event route is bound to.
     * @param filter An expression which describes the events which are routed to the endpoint.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.upsertEventRoute = function (eventRouteId, endpointId, filter, options) {
        if (options === void 0) { options = {}; }
        var eventRoutesAddOptionalParams = options;
        var eventRoute = {
            endpointName: endpointId,
            filter: filter
        };
        eventRoutesAddOptionalParams.eventRoute = eventRoute;
        var _a = createSpan("DigitalTwinsClient-upsertEventRoute", eventRoutesAddOptionalParams), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.eventRoutes.add(eventRouteId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * Delete an event route.
     *
     * @param eventRouteId The Id of the eventRoute to delete.
     * @param options The operation options
     * @returns The http response.
     */
    DigitalTwinsClient.prototype.deleteEventRoute = function (eventRouteId, options) {
        if (options === void 0) { options = {}; }
        var _a = createSpan("DigitalTwinsClient-deleteEventRoute", options), span = _a.span, updatedOptions = _a.updatedOptions;
        try {
            return this.client.eventRoutes.delete(eventRouteId, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    /**
     * @internal
     * Deals with the pagination of {@link query}.
     *
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     *
     */
    DigitalTwinsClient.prototype.queryTwinsPage = function (query, options, continuationState) {
        return __asyncGenerator(this, arguments, function queryTwinsPage_1() {
            var querySpecification, queryResult, querySpecification, queryResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        querySpecification = {
                            query: query,
                            continuationToken: continuationState.continuationToken
                        };
                        return [4 /*yield*/, __await(this.client.query.queryTwins(querySpecification, options))];
                    case 1:
                        queryResult = _a.sent();
                        continuationState.continuationToken = queryResult.continuationToken;
                        return [4 /*yield*/, __await(queryResult)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 8];
                        querySpecification = {
                            query: query,
                            continuationToken: continuationState.continuationToken
                        };
                        return [4 /*yield*/, __await(this.client.query.queryTwins(querySpecification, options))];
                    case 5:
                        queryResult = _a.sent();
                        continuationState.continuationToken = queryResult.continuationToken;
                        return [4 /*yield*/, __await(queryResult)];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * Deals with the iteration of all the available results of {@link query}.
     * @param {OperationOptions} [options] Common options for the iterative endpoints.
     */
    DigitalTwinsClient.prototype.queryTwinsAll = function (query, options) {
        return __asyncGenerator(this, arguments, function queryTwinsAll_1() {
            var f, _a, _b, page, _i, _c, item, e_5_1;
            var e_5, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        f = {};
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 10, 11, 16]);
                        _a = __asyncValues(this.queryTwinsPage(query, options, f));
                        _e.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        if (!page.value) return [3 /*break*/, 8];
                        _i = 0, _c = page.value;
                        _e.label = 4;
                    case 4:
                        if (!(_i < _c.length)) return [3 /*break*/, 8];
                        item = _c[_i];
                        return [4 /*yield*/, __await(item)];
                    case 5: return [4 /*yield*/, _e.sent()];
                    case 6:
                        _e.sent();
                        _e.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_5_1 = _e.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _e.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, __await(_d.call(_a))];
                    case 12:
                        _e.sent();
                        _e.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Query for digital twins.
     *
     * @param query The query string, in SQL-like syntax.
     * @param resultsPerPage The maximum number of items to retrieve per request. The server may choose to return less than the requested max.
     * @returns The pageable list of query results.
     */
    DigitalTwinsClient.prototype.queryTwins = function (query, resultsPerPage, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var queryQueryTwinsOptionalParams = options;
        queryQueryTwinsOptionalParams = {
            maxItemsPerPage: resultsPerPage
        };
        var _b = createSpan("DigitalTwinsClient-queryTwins", queryQueryTwinsOptionalParams), span = _b.span, updatedOptions = _b.updatedOptions;
        try {
            var iter_5 = this.queryTwinsAll(query, updatedOptions);
            return _a = {
                    next: function () {
                        return iter_5.next();
                    }
                },
                _a[Symbol.asyncIterator] = function () {
                    return this;
                },
                _a.byPage = function (settings) {
                    if (settings === void 0) { settings = {}; }
                    return _this.queryTwinsPage(query, queryQueryTwinsOptionalParams, settings);
                },
                _a;
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    };
    return DigitalTwinsClient;
}());
export { DigitalTwinsClient };
//# sourceMappingURL=digitalTwinsClient.js.map